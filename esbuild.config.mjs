import * as fs from "fs";
import * as path from "path";
import builtins from "builtin-modules";
import { Command } from "commander";
import dotenv from "dotenv";
import esbuild from "esbuild";
import manifest from "./manifest.json" with { type: "json" };
import packageJson from "./package.json" with { type: "json" };

// Initial configuration
dotenv.config({ path: [".env"] });

// Parsing command line arguments
const program = new Command();
program
	.option("-p, --production", "Production build")
	.option("-v, --vault [vault]", "Use vault path", false)
	.option("-o, --output-dir <path>", "Output path")
	.option("-b, --beta", "Pre-release version")
	.parse();

// Get options
const options = program.opts();
const isProd = !!options.production;
const isBeta = !!options.beta;
const isStyled = fs.existsSync("src/styles.css");
const pluginID = manifest.id;

// Banner for the output file
const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin: ${packageJson.repository}
*/`;

// Determine the output directory based on options
function resolveOutputDir() {
	if (options.outputDir) return options.outputDir;

	if (options.vault) {
		const vaultPath = typeof options.vault === "string"
			? options.vault
			: process.env.VAULT;

		if (!vaultPath) throw new Error("VAULT environment variable not set");

		const folderPath = path.join(vaultPath, ".obsidian", "plugins", pluginID);
		if (!fs.existsSync(folderPath)) fs.mkdirSync(folderPath, { recursive: true });

		if (!isProd) fs.writeFileSync(path.join(folderPath, ".hotreload"), "");

		return folderPath;
	}

	return isProd ? "./dist" : "./";
}

// Prepare the output directory
function prepareOutputDir(dir) {
	if ((isProd || options.outputDir) && fs.existsSync(dir)) {
		fs.rmSync(dir, { recursive: true });
	}

	if (isBeta && !fs.existsSync("manifest-beta.json")) {
		fs.copyFileSync("manifest.json", "manifest-beta.json");
	}
}

// Get plugins for esbuild
function getPlugins(outDir) {
	const plugins = [];

	// Plugin pour dÃ©placer les styles
	if (isStyled) {
		plugins.push({
			name: "move-styles",
			setup(build) {
				build.onEnd(() => {
					fs.copyFileSync("src/styles.css", path.join(outDir, "styles.css"));
				});
			}
		});
	}

	// Copy manifest file
	plugins.push({
		name: "copy-manifest",
		setup(build) {
			build.onEnd(() => {
				const manifestSource = isBeta ? "manifest-beta.json" : "manifest.json";
				fs.copyFileSync(manifestSource, path.join(outDir, "manifest.json"));
			});
		}
	});

	return plugins;
}

// Principal configuration
async function buildPlugin() {
	const outDir = resolveOutputDir();
	prepareOutputDir(outDir);

	const entryPoints = ["src/main.ts"];
	if (isStyled) entryPoints.push("src/styles.css");

	// CrÃ©er le contexte esbuild
	const context = await esbuild.context({
		banner: { js: banner },
		entryPoints,
		bundle: true,
		external: [
			"obsidian",
			"electron",
			"@codemirror/autocomplete",
			"@codemirror/collab",
			"@codemirror/commands",
			"@codemirror/language",
			"@codemirror/lint",
			"@codemirror/search",
			"@codemirror/state",
			"@codemirror/view",
			"@lezer/common",
			"@lezer/highlight",
			"@lezer/lr",
			...builtins,
		],
		format: "cjs",
		target: "esnext",
		logLevel: "info",
		sourcemap: isProd ? false : "inline",
		treeShaking: true,
		minify: isProd,
		minifySyntax: isProd,
		minifyWhitespace: isProd,
		outdir: outDir,
		plugins: getPlugins(outDir)
	});

	console.log(`ðŸš€ ${isProd ? 'Production' : 'Development'} build`);
	console.log(`ðŸ“¤ Output directory: ${outDir}`);

	if (isProd) {
		await context.rebuild();
		console.log("âœ… Build successful");
		process.exit(0);
	} else {
		await context.watch();
	}
}

buildPlugin().catch(err => {
	console.error("Build failed:", err);
	process.exit(1);
});